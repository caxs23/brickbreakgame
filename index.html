<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>벽돌깨기 게임 (중력 포함, 멀티볼, 아이템)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #1a1a1a;
      font-family: Arial, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      border: 2px solid #fff;
      background-color: #000;
      max-width: 100%;
      max-height: 80vh;
      display: block;
    }
    #ui {
      color: #fff;
      text-align: center;
      margin-bottom: 10px;
      font-size: 1.2em;
    }
    #pauseMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      color: #fff;
      text-align: center;
      display: none;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 1em;
      cursor: pointer;
      background-color: #4CAF50;
      border: none;
      border-radius: 5px;
      color: white;
    }
    button:hover {
      background-color: #45a049;
    }
    @media (max-width: 600px) {
      #ui {
        font-size: 1em;
      }
      canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <div id="ui">
    점수: <span id="score">0</span> | 
    레벨: <span id="level">1</span> | 
    라이프: <span id="lives">3</span> | 
    공 갯수: <span id="ballCount">1</span>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="pauseMenu">
    <h2>일시정지</h2>
    <button onclick="resumeGame()">계속하기</button><br>
    <button onclick="restartGame()">다시 시작</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const livesDisplay = document.getElementById('lives');
    const ballCountDisplay = document.getElementById('ballCount');
    const pauseMenu = document.getElementById('pauseMenu');

    // Game variables
    let paddle = {
      width: 120,
      height: 10,
      x: 0,
      y: 0,
      speed: 10,
      defaultWidth: 120
    };
    let brickRowCount = 5;
    let brickColumnCount = 9;
    let brickWidth = 80;
    let brickHeight = 20;
    let brickPadding = 10;
    let brickOffsetTop = 30;
    let brickOffsetLeft;
    const maxBalls = 80;

    // Canvas size
    function resizeCanvas() {
      canvas.width = Math.min(window.innerWidth * 0.9, 800);
      canvas.height = Math.min(window.innerHeight * 0.7, 600);
      brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding) - brickPadding)) / 2;
      paddle.x = canvas.width / 2 - paddle.width / 2;
      paddle.y = canvas.height - 20;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Other game variables
    let balls = [];
    let bricks = [];
    let score = 0;
    let level = 1;
    let lives = 3;
    let isPaused = false;
    let isGameOver = false;
    const gravity = 0.1;
    const acceleration = 1.001;
    let powerUp = null;
    let powerUpTimer = null;

    // Touch controls
    let touchX = null;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchX = e.touches[0].clientX;
    });
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const newTouchX = e.touches[0].clientX;
      const deltaX = newTouchX - touchX;
      paddle.x += deltaX * 0.12;
      touchX = newTouchX;
      paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
    });
    canvas.addEventListener('touchend', () => {
      touchX = null;
    });

    // Keyboard controls
    let rightPressed = false;
    let leftPressed = false;
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
      else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
      else if (e.key === 'p' || e.key === 'P') togglePause();
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
      else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
    });

    // Initialize bricks
    function createBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
        }
      }
    }

    // Draw functions
    function drawBall(ball) {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#ff4444';
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
      ctx.fillStyle = '#0095DD';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = `hsl(${r * 30}, 70%, 50%)`;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    function drawPowerUp() {
      if (powerUp) {
        ctx.beginPath();
        ctx.rect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
        ctx.fillStyle = '#FFD700';
        ctx.fill();
        ctx.closePath();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      balls.forEach(drawBall);
      drawPaddle();
      drawPowerUp();
      ballCountDisplay.textContent = balls.length;
    }

    // Collision detection for a single ball
    function collisionDetection(ball, ballIndex) {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            const closestX = Math.max(b.x, Math.min(ball.x, b.x + brickWidth));
            const closestY = Math.max(b.y, Math.min(ball.y, b.y + brickHeight));
            const distanceX = ball.x - closestX;
            const distanceY = ball.y - closestY;
            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

            if (distance <= ball.radius) {
              const overlapX = Math.abs(distanceX);
              const overlapY = Math.abs(distanceY);
              if (overlapX > overlapY) { // Fixed typo: overlayX -> overlapX
                ball.dx = -ball.dx;
              } else {
                ball.dy = -ball.dy;
              }
              b.status = 0;
              score += 10;
              scoreDisplay.textContent = score;
              playSound('brickHit');
              if (!powerUp && Math.random() < 0.1) {
                powerUp = {
                  x: b.x + brickWidth / 2 - 15,
                  y: b.y + brickHeight,
                  width: 30,
                  height: 15,
                  dy: 2
                };
              }
              if (score === brickRowCount * brickColumnCount * 10 * level) {
                levelUp();
              }
              return;
            }
          }
        }
      }
    }

    // Power-up logic
    function movePowerUp() {
      if (!powerUp) return;
      powerUp.y += powerUp.dy;
      if (
        powerUp.y + powerUp.height > paddle.y &&
        powerUp.y < paddle.y + paddle.height &&
        powerUp.x + powerUp.width > paddle.x &&
        powerUp.x < paddle.x + paddle.width
      ) {
        paddle.width += 50;
        clearTimeout(powerUpTimer);
        powerUpTimer = setTimeout(() => {
          paddle.width = paddle.defaultWidth;
        }, 10000);
        powerUp = null;
      }
      if (powerUp && powerUp.y > canvas.height) {
        powerUp = null;
      }
    }

    // Sound effects
    function playSound(type) {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      if (type === 'brickHit') {
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      }
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
    }

    // Game logic
    function moveBalls() {
      for (let i = balls.length - 1; i >= 0; i--) {
        let ball = balls[i];
        ball.dy += gravity;
        ball.dx *= acceleration;
        ball.dy *= acceleration;

        const maxSpeed = 10 + level * 2;
        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
        if (speed > maxSpeed) {
          const scale = maxSpeed / speed;
          ball.dx *= scale;
          ball.dy *= scale;
        }

        ball.x += ball.dx;
        ball.y += ball.dy;

        if (ball.x + ball.radius > canvas.width) {
          ball.x = canvas.width - ball.radius;
          ball.dx = -Math.abs(ball.dx);
          playSound('brickHit');
        }
        if (ball.x - ball.radius < 0) {
          ball.x = ball.radius;
          ball.dx = Math.abs(ball.dx);
          playSound('brickHit');
        }
        if (ball.y - ball.radius < 0) {
          ball.y = ball.radius;
          ball.dy = Math.abs(ball.dy);
          playSound('brickHit');
        }
        if (
          ball.y + ball.radius > paddle.y &&
          ball.y - ball.radius < paddle.y + paddle.height &&
          ball.x + ball.radius > paddle.x &&
          ball.x - ball.radius < paddle.x + paddle.width
        ) {
          const hitPoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
          ball.dx = 6 * hitPoint;
          ball.dy = -8 * (level / 2 + 1);
          playSound('brickHit');
          if (balls.length < maxBalls) {
            const newBall = {
              x: ball.x,
              y: ball.y,
              dx: -ball.dx * 0.8 + Math.random() * 2 - 1,
              dy: ball.dy * 0.8 + Math.random() * 2 - 1,
              radius: ball.radius
            };
            balls.push(newBall);
          }
        }
        if (ball.y + ball.radius > canvas.height) {
          balls.splice(i, 1);
        }
      }
      if (balls.length === 0) {
        lives--;
        livesDisplay.textContent = lives;
        if (lives === 0) {
          gameOver();
        } else {
          setTimeout(resetBalls, 1000);
        }
      }
      ballCountDisplay.textContent = balls.length;
    }

    function movePaddle() {
      if (rightPressed && paddle.x < canvas.width - paddle.width) {
        paddle.x += paddle.speed;
      } else if (leftPressed && paddle.x > 0) {
        paddle.x -= paddle.speed;
      }
    }

    function levelUp() {
      level++;
      levelDisplay.textContent = level;
      brickRowCount = Math.min(brickRowCount + 1, 8);
      resetBalls();
      createBricks();
      powerUp = null;
      clearTimeout(powerUpTimer);
      paddle.width = paddle.defaultWidth;
    }

    function resetBalls() {
      balls = [{
        x: canvas.width / 2,
        y: canvas.height - 50,
        dx: 4 * (level / 2 + 1),
        dy: -6 * (level / 2 + 1),
        radius: 10
      }];
      paddle.x = canvas.width / 2 - paddle.width / 2;
      ballCountDisplay.textContent = balls.length;
    }

    function gameOver() {
      isGameOver = true;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '30px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('게임 오버', canvas.width / 2, canvas.height / 2);
      ctx.fillText(`최종 점수: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
      pauseMenu.style.display = 'block';
    }

    function togglePause() {
      isPaused = !isPaused;
      pauseMenu.style.display = isPaused ? 'block' : 'none';
    }

    function resumeGame() {
      isPaused = false;
      pauseMenu.style.display = 'none';
      gameLoop();
    }

    function restartGame() {
      score = 0;
      level = 1;
      lives = 3;
      scoreDisplay.textContent = score;
      levelDisplay.textContent = level;
      livesDisplay.textContent = lives;
      isGameOver = false;
      isPaused = false;
      pauseMenu.style.display = 'none';
      brickRowCount = 5;
      paddle.width = paddle.defaultWidth;
      clearTimeout(powerUpTimer);
      powerUp = null;
      resetBalls();
      createBricks();
      gameLoop();
    }

    // Game loop
    function gameLoop() {
      if (!isPaused && !isGameOver) {
        movePaddle();
        moveBalls();
        movePowerUp();
        balls.forEach((ball, index) => collisionDetection(ball, index));
        draw();
        requestAnimationFrame(gameLoop);
      }
    }

    // Start game
    createBricks();
    resetBalls();
    gameLoop();
  </script>
</body>
</html>
