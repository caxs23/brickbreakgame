<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>벽돌깨기 게임</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #1a1a1a;
      font-family: Arial, sans-serif;
      overflow: hidden;
      touch-action: none; /* Prevent default touch behaviors */
    }
    canvas {
      border: 2px solid #fff;
      background-color: #000;
      max-width: 100%;
      max-height: 80vh;
      display: block;
    }
    #ui {
      color: #fff;
      text-align: center;
      margin-bottom: 10px;
      font-size: 1.2em;
    }
    #pauseMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      color: #fff;
      text-align: center;
      display: none;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 1em;
      cursor: pointer;
      background-color: #4CAF50;
      border: none;
      border-radius: 5px;
      color: white;
    }
    button:hover {
      background-color: #45a049;
    }
    @media (max-width: 600px) {
      #ui {
        font-size: 1em;
      }
      canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <div id="ui">
    점수: <span id="score">0</span> | 
    레벨: <span id="level">1</span> | 
    라이프: <span id="lives">3</span>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="pauseMenu">
    <h2>일시정지</h2>
    <button onclick="resumeGame()">계속하기</button><br>
    <button onclick="restartGame()">다시 시작</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const livesDisplay = document.getElementById('lives');
    const pauseMenu = document.getElementById('pauseMenu');

    // Canvas size
    function resizeCanvas() {
      canvas.width = Math.min(window.innerWidth * 0.9, 800);
      canvas.height = Math.min(window.innerHeight * 0.7, 600);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game variables
    let ball = {
      x: canvas.width / 2,
      y: canvas.height - 50,
      dx: 4,
      dy: -4,
      radius: 10
    };
    let paddle = {
      width: 100,
      height: 10,
      x: canvas.width / 2 - 50,
      y: canvas.height - 20,
      speed: 8
    };
    let bricks = [];
    let score = 0;
    let level = 1;
    let lives = 3;
    let isPaused = false;
    let isGameOver = false;
    let brickRowCount = 5;
    let brickColumnCount = 9;
    let brickWidth = 80;
    let brickHeight = 20;
    let brickPadding = 10;
    let brickOffsetTop = 30;
    let brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding) - brickPadding)) / 2;

    // Touch controls
    let touchX = null;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchX = e.touches[0].clientX;
    });
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const newTouchX = e.touches[0].clientX;
      const deltaX = newTouchX - touchX;
      paddle.x += deltaX * 0.1; // Adjust sensitivity
      touchX = newTouchX;
      paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
    });
    canvas.addEventListener('touchend', () => {
      touchX = null;
    });

    // Keyboard controls
    let rightPressed = false;
    let leftPressed = false;
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
      else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
      else if (e.key === 'p' || e.key === 'P') togglePause();
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
      else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
    });

    // Initialize bricks
    function createBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
        }
      }
    }

    // Draw functions
    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#ff4444';
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
      ctx.fillStyle = '#0095DD';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = `hsl(${r * 30}, 70%, 50%)`;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
    }

    // Collision detection
    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            if (
              ball.x > b.x &&
              ball.x < b.x + brickWidth &&
              ball.y > b.y &&
              ball.y < b.y + brickHeight
            ) {
              ball.dy = -ball.dy;
              b.status = 0;
              score += 10;
              scoreDisplay.textContent = score;
              playSound('brickHit');
              if (score === brickRowCount * brickColumnCount * 10) {
                levelUp();
              }
            }
          }
        }
      }
    }

    // Sound effects (using simple oscillator for browser compatibility)
    function playSound(type) {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      if (type === 'brickHit') {
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      }
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
    }

    // Game logic
    function moveBall() {
      ball.x += ball.dx;
      ball.y += ball.dy;

      if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx = -ball.dx;
        playSound('brickHit');
      }
      if (ball.y - ball.radius < 0) {
        ball.dy = -ball.dy;
        playSound('brickHit');
      }
      if (
        ball.y + ball.radius > paddle.y &&
        ball.x > paddle.x &&
        ball.x < paddle.x + paddle.width
      ) {
        ball.dy = -ball.dy;
        playSound('brickHit');
      }
      if (ball.y + ball.radius > canvas.height) {
        lives--;
        livesDisplay.textContent = lives;
        if (lives === 0) {
          gameOver();
        } else {
          resetBall();
        }
      }
    }

    function movePaddle() {
      if (rightPressed && paddle.x < canvas.width - paddle.width) {
        paddle.x += paddle.speed;
      } else if (leftPressed && paddle.x > 0) {
        paddle.x -= paddle.speed;
      }
    }

    function levelUp() {
      level++;
      levelDisplay.textContent = level;
      ball.dx *= 1.1;
      ball.dy *= 1.1;
      brickRowCount = Math.min(brickRowCount + 1, 8);
      resetBall();
      createBricks();
    }

    function resetBall() {
      ball.x = canvas.width / 2;
      ball.y = canvas.height - 50;
      ball.dx = 4 * (level / 2 + 1);
      ball.dy = -4 * (level / 2 + 1);
      paddle.x = canvas.width / 2 - paddle.width / 2;
    }

    function gameOver() {
      isGameOver = true;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '30px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('게임 오버', canvas.width / 2, canvas.height / 2);
      ctx.fillText(`최종 점수: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
      pauseMenu.style.display = 'block';
    }

    function togglePause() {
      isPaused = !isPaused;
      pauseMenu.style.display = isPaused ? 'block' : 'none';
    }

    function resumeGame() {
      isPaused = false;
      pauseMenu.style.display = 'none';
      gameLoop();
    }

    function restartGame() {
      score = 0;
      level = 1;
      lives = 3;
      scoreDisplay.textContent = score;
      levelDisplay.textContent = level;
      livesDisplay.textContent = lives;
      isGameOver = false;
      isPaused = false;
      pauseMenu.style.display = 'none';
      brickRowCount = 5;
      resetBall();
      createBricks();
      gameLoop();
    }

    // Game loop
    function gameLoop() {
      if (!isPaused && !isGameOver) {
        movePaddle();
        moveBall();
        collisionDetection();
        draw();
        requestAnimationFrame(gameLoop);
      }
    }

    // Start game
    createBricks();
    gameLoop();
  </script>
</body>
</html>
