<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>벽돌깨기 게임 (중력 포함, 멀티볼, 아이템)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #1a1a1a;
      font-family: Arial, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      border: 2px solid #fff;
      background-color: #000;
      max-width: 100%;
      max-height: 90vh;
      display: block;
      width: 100%;
      height: auto;
    }
    #ui {
      color: #fff;
      text-align: center;
      margin-bottom: 10px;
      font-size: clamp(0.9em, 3.5vw, 1.1em);
    }
    #pauseMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      color: #fff;
      text-align: center;
      display: none;
      font-size: clamp(0.9em, 2.5vw, 1.1em);
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: clamp(0.8em, 3vw, 1em);
      cursor: pointer;
      background-color: #4CAF50;
      border: none;
      border-radius: 5px;
      color: white;
      touch-action: manipulation;
    }
    button:hover {
      background-color: #45a049;
    }
    @media (max-width: 600px) {
      canvas {
        width: 100%;
        height: auto;
        aspect-ratio: 9 / 16;
      }
    }
  </style>
</head>
<body>
  <div id="ui">
    점수: <span id="score">0</span> | 
    레벨: <span id="level">1</span> | 
    라이프: <span id="lives">3</span> | 
    공 갯수: <span id="ballCount">1</span>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="pauseMenu">
    <h2>일시정지</h2>
    <button onclick="resumeGame()">계속하기</button><br>
    <button onclick="restartGame()">다시 시작</button>
    <button onclick="resumeGame()">계속하기(스페이스바)</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const livesDisplay = document.getElementById('lives');
    const ballCountDisplay = document.getElementById('ballCount');
    const pauseMenu = document.getElementById('pauseMenu');

    // Game variables
    let paddle = {
      width: 150,
      height: 20,
      x: 0,
      y: 0,
      speed: 20,
      defaultWidth: 150
    };
    let brickRowCount = 5;
    let brickColumnCount = 9;
    let brickWidth = 80;
    let brickHeight = 20;
    let brickPadding = 10;
    let brickOffsetTop = 30;
    let brickOffsetLeft;
    const maxBalls = 80;
    const gravity = 0.05; // 중력 감소
    const acceleration = 1.001;
    let balls = [];
    let bricks = [];
    let score = 0;
    let level = 1;
    let lives = 3;
    let isPaused = false;
    let isGameOver = false;
    let isGameWon = false;
    let waitingForRestart = false;
    let powerUp = null;
    let powerUpTimer = null;
    let lastTime = performance.now();

    // Canvas size
    function resizeCanvas() {
      const aspectRatio = window.innerWidth <= 600 ? 9 / 16 : 4 / 3;
      const maxWidth = Math.min(window.innerWidth * 0.95, 800);
      const maxHeight = Math.min(window.innerHeight * 0.85, 600);
      canvas.width = maxWidth;
      canvas.height = maxWidth / aspectRatio;
      if (canvas.height > maxHeight) {
        canvas.height = maxHeight;
        canvas.width = maxHeight * aspectRatio;
      }
      brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding) - brickPadding)) / 2;
      paddle.x = canvas.width / 2 - paddle.width / 2;
      paddle.y = canvas.height - (window.innerWidth <= 600 ? 60 : 40);
      brickWidth = canvas.width / 10;
      brickHeight = canvas.height / 30;
      brickPadding = canvas.width / 80;
      brickOffsetTop = canvas.height / 15;
      paddle.width = canvas.width / 5; // 패들 너비 증가 (기존: 1/6.67)
      paddle.defaultWidth = paddle.width;
      paddle.height = canvas.height / 40; // 패들 높이 증가 (기존: 1/60)
      paddle.speed = canvas.width / 50;
      balls.forEach(ball => {
        ball.radius = canvas.width / 60; // 공 반지름 증가 (기존: 1/80)
        ball.x = Math.min(ball.x, canvas.width - ball.radius);
        ball.y = Math.min(ball.y, canvas.height - ball.radius);
      });
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Touch controls
    let touchX = null;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchX = e.touches[0].clientX;
    });
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const newTouchX = e.touches[0].clientX;
      const deltaX = newTouchX - touchX;
      paddle.x += deltaX * (window.innerWidth < 600 ? 0.8 : 0.16);
      touchX = newTouchX;
      paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
    });
    canvas.addEventListener('touchend', () => {
      touchX = null;
    });

    // Keyboard controls
    let rightPressed = false;
    let leftPressed = false;
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
      else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
      else if (e.key === 'p' || e.key === 'P') togglePause();
      else if (e.key === ' ' && waitingForRestart && !isGameOver && !isGameWon) {
        resumeGame();
      }
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
      else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
    });

    // Initialize bricks
    function createBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
        }
      }
    }

    // Draw functions
    function drawBall(ball) {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#ff4444';
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
      ctx.fillStyle = '#0095DD';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = `hsl(${r * 30}, 70%, 50%)`;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    function drawPowerUp() {
      if (powerUp) {
        ctx.beginPath();
        ctx.rect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
        ctx.fillStyle = '#FFD700';
        ctx.fill();
        ctx.closePath();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      balls.forEach(drawBall);
      drawPaddle();
      drawPowerUp();
      ballCountDisplay.textContent = balls.length;
      if (waitingForRestart && !isGameOver && !isGameWon) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = `${canvas.width / 26.67}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('공을 잃었습니다!', canvas.width / 2, canvas.height / 2 - canvas.width / 20);
        ctx.fillText('스페이스바 또는 계속하기 버튼을 눌러 계속', canvas.width / 2, canvas.height / 2 + canvas.width / 20);
      }
      if (isGameWon) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = `${canvas.width / 26.67}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('승리!', canvas.width / 2, canvas.height / 2);
        ctx.fillText(`최종 점수: ${score}`, canvas.width / 2, canvas.height / 2 + canvas.width / 20);
      }
    }

    // Collision detection for a single ball
    function collisionDetection(ball, ballIndex) {
      let remainingBricks = 0;
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            remainingBricks++;
            const closestX = Math.max(b.x, Math.min(ball.x, b.x + brickWidth));
            const closestY = Math.max(b.y, Math.min(ball.y, b.y + brickHeight));
            const distanceX = ball.x - closestX;
            const distanceY = ball.y - closestY;
            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

            if (distance <= ball.radius) {
              const overlapX = Math.abs(distanceX);
              const overlapY = Math.abs(distanceY);
              if (overlapX > overlapY) {
                ball.dx = -ball.dx;
              } else {
                ball.dy = -ball.dy;
              }
              b.status = 0;
              score += 10;
              scoreDisplay.textContent = score;
              playSound('brickHit');
              if (!powerUp && Math.random() < 0.1) {
                powerUp = {
                  x: b.x + brickWidth / 2 - canvas.width / 26.67,
                  y: b.y + brickHeight,
                  width: canvas.width / 26.67,
                  height: canvas.height / 40,
                  dy: canvas.height / 300
                };
              }
              remainingBricks--;
            }
          }
        }
      }
      if (remainingBricks === 0) {
        if (level === 5) {
          gameWon();
        } else {
          levelUp();
        }
      }
    }

    // Power-up logic
    function movePowerUp(deltaTime) {
      if (!powerUp) return;
      powerUp.y += powerUp.dy * deltaTime * 60;
      if (
        powerUp.y + powerUp.height > paddle.y &&
        powerUp.y < paddle.y + paddle.height &&
        powerUp.x + powerUp.width > paddle.x &&
        powerUp.x < paddle.x + paddle.width
      ) {
        paddle.width += canvas.width / 16;
        clearTimeout(powerUpTimer);
        powerUpTimer = setTimeout(() => {
          paddle.width = paddle.defaultWidth;
        }, 10000);
        powerUp = null;
      }
      if (powerUp && powerUp.y > canvas.height) {
        powerUp = null;
      }
    }

    // Sound effects
    function playSound(type) {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      if (type === 'brickHit') {
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      }
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
    }

    // Game logic
    function moveBalls(deltaTime) {
      for (let i = balls.length - 1; i >= 0; i--) {
        let ball = balls[i];
        ball.dy += gravity * deltaTime * 60 * (canvas.width / 800);
        ball.dx *= Math.pow(acceleration, deltaTime * 60);
        ball.dy *= Math.pow(acceleration, deltaTime * 60);

        const maxSpeed = (15 + level * 3) * (canvas.width / 800); // 최대 속도 증가
        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
        if (speed > maxSpeed) {
          const scale = maxSpeed / speed;
          ball.dx *= scale;
          ball.dy *= scale;
        }

        ball.x += ball.dx * deltaTime * 60;
        ball.y += ball.dy * deltaTime * 60;

        if (ball.x + ball.radius > canvas.width) {
          ball.x = canvas.width - ball.radius;
          ball.dx = -Math.abs(ball.dx);
          playSound('brickHit');
        }
        if (ball.x - ball.radius < 0) {
          ball.x = ball.radius;
          ball.dx = Math.abs(ball.dx);
          playSound('brickHit');
        }
        if (ball.y - ball.radius < 0) {
          ball.y = ball.radius;
          ball.dy = Math.abs(ball.dy);
          playSound('brickHit');
        }
        if (
          ball.y + ball.radius > paddle.y &&
          ball.y - ball.radius < paddle.y + paddle.height &&
          ball.x + ball.radius > paddle.x &&
          ball.x - ball.radius < paddle.x + paddle.width
        ) {
          const hitPoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
          ball.dx = 8 * hitPoint * (canvas.width / 800); // 수평 속도 증가
          ball.dy = -10 * (level / 2 + 1) * (canvas.width / 800); // 수직 속도 증가
          playSound('brickHit');
          if (balls.length < maxBalls) {
            const ballsToAdd = Math.min(level + 1, maxBalls - balls.length + 1);
            for (let j = 0; j < ballsToAdd - 1; j++) {
              if (balls.length < maxBalls) {
                const newBall = {
                  x: ball.x,
                  y: ball.y,
                  dx: -ball.dx * 0.8 + (Math.random() * 2 - 1) * (canvas.width / 800),
                  dy: ball.dy * 0.8 + (Math.random() * 2 - 1) * (canvas.width / 800),
                  radius: ball.radius
                };
                balls.push(newBall);
              }
            }
          }
        }
        if (ball.y + ball.radius > canvas.height) {
          balls.splice(i, 1);
        }
      }
      if (balls.length === 0 && !waitingForRestart && !isGameOver && !isGameWon) {
        lives--;
        livesDisplay.textContent = lives;
        waitingForRestart = true;
        pauseMenu.style.display = 'block';
      }
      ballCountDisplay.textContent = balls.length;
    }

    function movePaddle() {
      if (rightPressed && paddle.x < canvas.width - paddle.width) {
        paddle.x += paddle.speed;
      } else if (leftPressed && paddle.x > 0) {
        paddle.x -= paddle.speed;
      }
      paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
    }

    function resetBalls() {
      balls = [{
        x: canvas.width / 2,
        y: canvas.height - 60,
        dx: 4 * (level / 2 + 1) * (canvas.width / 800),
        dy: -12 * (level / 2 + 1) * (canvas.width / 800), // 초기 수직 속도 증가
        radius: canvas.width / 60 // 공 반지름 증가
      }];
      paddle.x = canvas.width / 2 - paddle.width / 2;
      ballCountDisplay.textContent = balls.length;
      waitingForRestart = false;
    }

    function levelUp() {
      level = Math.min(level + 1, 5);
      levelDisplay.textContent = level;
      brickRowCount = Math.min(brickRowCount + 1, 8);
      resetBalls();
      createBricks();
      powerUp = null;
      clearTimeout(powerUpTimer);
      paddle.width = paddle.defaultWidth;
    }

    function gameOver() {
      isGameOver = true;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = `${canvas.width / 26.67}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText('게임 오버', canvas.width / 2, canvas.height / 2);
      ctx.fillText(`최종 점수: ${score}`, canvas.width / 2, canvas.height / 2 + canvas.width / 20);
      pauseMenu.style.display = 'block';
    }

    function gameWon() {
    isGameWon = true;
    pauseMenu.style.display = 'block';

    // 일시정지 메뉴의 내용을 승리 메시지로 변경
    const menuTitle = pauseMenu.querySelector('h2');
    menuTitle.textContent = '승리!';

    const continueButton = pauseMenu.querySelector('button:nth-of-type(1)');
    continueButton.style.display = 'none'; // '계속하기' 버튼 숨기기

    const restartButton = pauseMenu.querySelector('button:nth-of-type(2)');
    restartButton.style.display = 'block'; // '다시 시작' 버튼 표시

    const spacebarButton = pauseMenu.querySelector('button:nth-of-type(3)');
    spacebarButton.style.display = 'none'; // '계속하기(스페이스바)' 버튼 숨기기
}

    function togglePause() {
      if (isGameWon || waitingForRestart) return;
      isPaused = !isPaused;
      pauseMenu.style.display = isPaused ? 'block' : 'none';
    }

    function resumeGame() {
      if (isGameWon) return;
      isPaused = false;
      pauseMenu.style.display = 'none';
      if (waitingForRestart) {
        if (lives > 0) {
          resetBalls();
        } else {
          gameOver();
        }
      }
      lastTime = performance.now();
      gameLoop();
    }

    function restartGame() {
      score = 0;
      level = 1;
      lives = 3;
      scoreDisplay.textContent = score;
      levelDisplay.textContent = level;
      livesDisplay.textContent = lives;
      isGameOver = false;
      isGameWon = false;
      isPaused = false;
      waitingForRestart = false;
      pauseMenu.style.display = 'none';
      brickRowCount = 5;
      paddle.width = paddle.defaultWidth;
      clearTimeout(powerUpTimer);
      powerUp = null;
      resetBalls();
      createBricks();
      lastTime = performance.now();
      gameLoop();
    }

    // Game loop
    function gameLoop() {
      if (!isPaused && !isGameOver && !isGameWon && !waitingForRestart) {
        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        movePaddle();
        moveBalls(deltaTime);
        movePowerUp(deltaTime);
        balls.forEach((ball, index) => collisionDetection(ball, index));
        draw();
        requestAnimationFrame(gameLoop);
      } else {
        draw();
      }
    }

    // Start game
    createBricks();
    resetBalls();
    resizeCanvas(); // 벽돌버그 해결
    gameLoop();
  </script>
</body>
</html>
